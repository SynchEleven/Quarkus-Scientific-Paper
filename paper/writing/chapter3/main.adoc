=== Datamodel
The next goal is to make the first reactive endpoint. But first, we are going to make a simple model so that we have something to handle for our HTTP requests.

==== First Panache Model
Since we are using the "Hibernate Reactive with Panache" extension, we are making a Panache Entity called User, which stores a username and an email. These models are the same as usual if you are familiar with Hibernate and java persistence annotations, the only thing different is that the model inherits from PanacheEntity (make sure to import the reactive version), making it a domain model capable of being handled by Panache:

[source, java]
----
@Entity
@Cacheable
public class User extends PanacheEntity {
    @Column(length = 64)
    public String username;
    @Column(unique = true)
    public String email;
}
----

==== Database configuration
We added the postgreSQL reactive extension, but without configuration it will not do anything for us. Therefore, we need to configure it in the application.properties as follows:

----
quarkus.datasource.db-kind=postgresql
quarkus.hibernate-orm.database.generation=drop-and-create
----

Now Quarkus will use the PostgreSQL database as a datasource and it will handle the DB generation. 

===== Dev Services

link:https://quarkus.io/guides/dev-services[Dev Services] are provided by Quarkus as out-of-the-box configured extension. These include databases like mongoDB or PostgreSQL for example, which you just have to add as an extension and can instantly use without any further configuration - most of the time they are automatically run inside of a Testcontainer. These services are just for test and development purposes only, but allow one to easliy change and try a lot of different databases without changing a bunch of configurations. 

Since PostgreSQL, that we are using in this demonstration, is a so called link:https://quarkus.io/guides/dev-services[Dev Service], Quarkus will setup the database for us and we just have to specify it as our datasource.


===== SQL script
Since we are currently telling the db to always "drop-and-create" for debugging purposes, we are going to create a simple import.sql script in the same directory as application.properties so that it is executed on creation and we have some sample data to work with.

[,sql]
----
INSERT INTO user(id, username, email) VALUES (nextval('hibernate_sequence'), 'Max Musterman', 'max@musterman.at');
INSERT INTO user(id, username, email) VALUES (nextval('hibernate_sequence'), 'Hans Klaus', 'hans@klaus.at');
INSERT INTO user(id, username, email) VALUES (nextval('hibernate_sequence'), 'Justin Clown', 'justin@clown.at');
----

==== Reactive Resources
Since our interactions with the database are non-blocking now, our HTTP resources (endpoints) have to be constructed asynchronously as well. For this we are using link:https://quarkus.io/guides/mutiny-primer[Mutiny's] Uni and Multi as return-types in this demonstration, since the Panache Entities also expose methods using these types. Nevertheless, are link:https://kotlinlang.org/docs/coroutines-overview.html[Kotlin Coroutines] also a valid solution for this task. 

Uni => emits a single event (an item on success or a failure) - basically represents an asynchronous action that returns 0 or 1

Multi => emits multiple events (n items, 1 failure or 1 completion) - these could represent streams of items

==== Create the Resource

